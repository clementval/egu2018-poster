\documentclass{beamer}
\usepackage[orientation=portrait,size=a0,scale=1.4,debug]{beamerposter}
\mode<presentation>{\usetheme{c2sm}}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{siunitx} %pretty measurement unit rendering
\usepackage{hyperref} %enable hyperlink for urls
\usepackage{ragged2e}
\usepackage{pgfplots}
\usepackage[font=scriptsize,justification=justified]{caption}
\usepackage{array,booktabs,tabularx}
\usepackage{listings}

\usepgfplotslibrary{external}
\tikzexternalize
\pgfplotsset{compat=1.5}



\newcolumntype{Z}{>{\centering\arraybackslash}X} % centered tabularx columns
\sisetup{per=frac,fraction=sfrac}

\title{\huge Performance portability on GPU and CPU with the ICON global climate model}
\author{Valentin Clement$^{1}$, Philippe Marti$^{1}$, Oliver Fuhrer$^{2}$, William Sawyer$^{3}$}
\institute[ETH]{
$^{1}$ETH Zurich, Center for Climate Systems Modeling (C2SM), Zurich, Switerzland \\
$^{2}$Federal Office of Meteorology and Climatology MeteoSwiss, Zurich, Switzerland \\
$^{3}$CSCS Swiss National Supercomputing Centre, Lugano, Switzerland
}
\date{\today}

\definecolor{darkgreen}{rgb}{0,0.4,0}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{Gray}{rgb}{0,0,0}
\definecolor{LightGray}{gray}{0.9}
\definecolor{orange}{HTML}{C15900}
\definecolor{color1}{HTML}{FFFFCC}
\definecolor{color2}{HTML}{A1DAB4}
\definecolor{color3}{HTML}{41B6C4}
\definecolor{color4}{HTML}{225EA8}
\definecolor{bblack}{HTML}{000000}

\tikzstyle{process} = [rectangle, rounded corners, minimum width=12cm, minimum height=2cm,text centered, draw=black, fill=color2]
\tikzstyle{tmp} = [rectangle, minimum width=12cm, minimum height=2cm, text centered, draw=black, fill=color3]
\tikzstyle{fortran} = [rectangle, minimum width=12cm, minimum height=2cm, text centered, draw=black, fill=LightGray]
\tikzstyle{arrow} = [thick,->,>=stealth]


\lstset{
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\color{orange},
  identifierstyle=\color{black},
  commentstyle=\color{gray},
  stringstyle=\color{red},
  numbers=left,
  numberstyle=\color{Gray}\tiny,
  %frame=bt,
  %frame=single,
  %rulecolor=\color{Gray},
  numbersep=7pt,
  extendedchars=true,
  captionpos=b,
  breaklines=true,
  showspaces=false,
  showtabs=false,
  tabsize=2,
  xleftmargin=20pt,
  framexleftmargin=20pt,
  framexrightmargin=0pt,
  framextopmargin=0pt,
  framexbottommargin=0pt,
  showstringspaces=false,
  aboveskip=20pt,
  belowskip=20pt,
}

% edit this depending on how tall your header is. We should make this scaling automatic :-/
\newlength{\columnheight}
\setlength{\columnheight}{104cm}




\begin{document}

\defverbatim\clawa{%
\begin{lstlisting}
!$claw define dimension dim_id(LB:UB) &
[!$claw define dimension dim_id(LB:UB) &] ...
!$claw parallelize [data(var_1[,var_2] ...)] [&]
[!$claw over (dim_id|:[,dim_id|:] ...)]
\end{lstlisting}
}

\begin{frame}
\begin{columns}
\begin{column}{.43\textwidth}
\begin{beamercolorbox}[center]{postercolumn}
\begin{minipage}{.98\textwidth}  % tweaks the width, makes a new \textwidth
\parbox[t][\columnheight]{\textwidth}{ % must be some better way to set the the height, width and textwidth simultaneously

%
% Block 1
%
\begin{myblock}{Porting ICON to hybrid architecture}
In order to prepare for new supercomputer architectures, the global climate
model ICON is being ported to GPU. The major part of the porting is achieved
using OpenACC~\cite{Lapillonne2014} compiler directives. For time-critical
components such as physical parametrizations, code restructuring and
optimizations are necessary to obtain optimal performance. In some cases,
these GPU-optimizations may have a negative impact when running the same code
on a CPU architecture. In order to address such performance portability issues
without imposing disturbing changes to the code base, the CLAW Single Column
Abstraction (SCA) is introduced. It is designed to address the physical
parametrizations of atmospheric models which are horizontally independent so
each column can be computed separately. With this approach, the physical
parametrization is written in Fortran only considering the vertical
dependencies. The CLAW Compiler can transform the code for a specific
target architecture and insert compiler directives such as OpenMP or OpenACC.
\end{myblock}%\vfill

%
% Block 2
%
\begin{myblock}{Performance protability}
Restructuring the code to achieve better performance on a specific architecture
can a negative impact on another one. This can be shown between an x86 and a
GPU architecture.

\begin{figure}[ht]
\begin{tikzpicture}
  \tikzstyle{every node}=[font=\small]
  \begin{axis}[
    height = 17cm,
    major x tick style = transparent,
    ybar=2*\pgflinewidth,
    bar width=36pt,
    ymajorgrids = true,
    ylabel = {Execution time [s]},
    symbolic x coords={Executed on CPU, Executed on GPU},
    xtick = data,
    scaled y ticks = false,
    enlarge x limits=0.25,
    ymin=0,
    legend cell align=left,
    legend style={
      at={(1,1)},
      anchor=north east,
      column sep=1ex
    }
    ]
    \addplot[style={bblack,fill=color2,mark=none}]
      coordinates {(Executed on CPU, 0.8863) (Executed on GPU, 0.51135)};

    \addplot[style={bblack,fill=color4,mark=none}]
      coordinates {(Executed on CPU, 1.12311) (Executed on GPU, 0.33642)};

    \legend{CPU optimized loop structure, GPU optimized loop structure}
  \end{axis}
\end{tikzpicture}
\caption[Performance Portability comparison]{Performance Portability comparison}
\label{fig:perfportability}
\end{figure}

Figure~\ref{fig:perfportability} shows the kind of performance impact one can
expect on typical physical parameterization code.
\begin{itemize}
  \item CPU structured code executed on GPU leaves about \textbf{35\% of
        achievable performance behind}.
  \item GPU structured code is about \textbf{30\% solver} when executed on CPU.
\end{itemize}

\end{myblock}%\vfill

\begin{myblock}{CLAW Single Column Abstraction}
The CLAW Single Column Abstraction aims to achieve performance portability
on different target architectures with a single source code.
The horizontal dimensions can be completely abstracted as they do not impose
any data dependency in their iteration space.
This information gives the flexibility to the CLAW Compiler to introduce
back these dimensions at compile time where it is beneficial depending on the
target architecture.

A code restructured for CLAW SCA has the following properties:
\begin{itemize}
  \item Arrays containing horizontal dimensions are demoted.
  \item DO statements over the horizontal dimensions are removed.
  \item The subroutine to be transformed is encapsulated in a module to take
        advantage of cross-file transformation.
  \item The code is annotated with the CLAW SCA directive to drive the CLAW
        Compiler. The directive is shown below.
\end{itemize}

\clawa

\end{myblock}\vfill

}\end{minipage}\end{beamercolorbox}
\end{column}

%
% COLUMN 2
%
\begin{column}{.57\textwidth}
\begin{beamercolorbox}[center]{postercolumn}
\begin{minipage}{.98\textwidth} % tweaks the width, makes a new \textwidth
\parbox[t][\columnheight]{\textwidth}{ % must be some better way to set the the height, width and textwidth simultaneously

%
% Block 3
%
\begin{myblock}{CLAW Compiler}
The CLAW Compiler is:
\begin{itemize}
  \item An \textbf{open-source} source-to-source compiler.
  \item Able to understand the CLAW SCA directives and produce \textbf{optimized
        code} for specific target architecture and compiler directives.
  \item Based on the \textbf{OMNI Compiler Project}\cite{Omni} developed at
        RIKEN RCCS in Kobe, Japan.
  \item Easily extensible to new architectures.
\end{itemize}

\begin{figure}
  \begin{tikzpicture}[node distance=2.5cm]
    \node (inf90) [fortran] {original.f90};
    \node (fpp) [process, below of=inf90] {FPP};
    \node (inf90fpp) [tmp, below of=fpp] {original.pp.f90};
    \node (ffront) [process, below of=inf90fpp] {OMNI F-Front};
    \node (xcodemlin) [tmp, below of=ffront] {XcodeML/F IR input};

    \node (clawx2t) [process, right of=fpp, xshift=12cm] {CLAW X2T};
    \node (xcodemlout) [tmp, below of=clawx2t] {XcodeML/F IR output};
    \node (fback) [process, below of=xcodemlout] {OMNI F-Back};
    \node (transformed) [fortran, below of=fback] {transformed.f90};

    \draw [arrow] (inf90) -- (fpp);
    \draw [arrow] (fpp) -- (inf90fpp);
    \draw [arrow] (inf90fpp) -- (ffront);
    \draw [arrow] (ffront) -- (xcodemlin);
    \draw [arrow] (xcodemlin.east) -| ++(+1.5cm,+3cm) |- (clawx2t.west);
    \draw [arrow] (clawx2t) -- (xcodemlout);
    \draw [arrow] (xcodemlout) -- (fback);
    \draw [arrow] (fback) -- (transformed);
  \end{tikzpicture}
  \caption[CLAW Compiler workflow]{CLAW Compiler workflow}
  \label{fig:clawfc}
\end{figure}

Fortran code is preprocessed and then parsed to the XcodeML/F IR. This IR
represented as an AST is then manipulated
to produce the different version of the code for a specific target. Finally, the
IR is decompiled to standard Fortran code before being compiled by default
compilers.

\raisebox{-.4\height}{\includegraphics[height=3cm, keepaspectratio]{resources/github}} https://github.com/claw-project

\end{myblock}\vfill

%
% Block 4
%
\begin{myblock}{Current results}
To demonstrate the CLAW SCA approach and the use of the CLAW Compiler in a real
life example, we applied it to the short-wave solver of the RRTMGP radiation
code.

\begin{figure}[ht]
  \begin{tikzpicture}
    \tikzstyle{every node}=[font=\small]
    \begin{axis}[
      title = {A) x86 parallel target vs. seq},
      title style={at={(0.5,-0.15)},anchor=north,yshift=0.5},
      width = 0.45*\textwidth,
      major x tick style = transparent,
      ybar=2*\pgflinewidth,
      bar width=30pt,
      ymajorgrids = true,
      ytick = {0,1,2,3,4,5,6,7,8},
      ylabel = {Speedup},
      symbolic x coords={GNU v7.1, Cray CCE v8.6.2, PGI v17.10},
      xtick = data,
      scaled y ticks = true,
      enlarge x limits=0.25,
      ymin=0,
      legend cell align=left,
      legend style={
        at={(1,1.02)},
        anchor=south east,
        column sep=1ex
      }
    ]
    \addplot[style={bblack,fill=white,mark=none}]
      coordinates {(GNU v7.1, 0.56) (Cray CCE v8.6.2, 1.0) (PGI v17.10, 0.89)};
    \addplot[style={bblack,fill=color2,mark=none}]
      coordinates {(GNU v7.1,0.18) (Cray CCE v8.6.2, 0.22) (PGI v17.10, 0.20)};
    \addplot[style={bblack,fill=color3,mark=none}]
      coordinates {(GNU v7.1, 5.6) (Cray CCE v8.6.2, 7.7) (PGI v17.10, 6.5)};
    \addplot[style={bblack,fill=color4,mark=none}]
      coordinates {(GNU v7.1, 1.25) (Cray CCE v8.6.2, 1.6) (PGI v17.10, 1.3)};

    \legend{Original code (1core) (ref.), CLAW SCA (1core), CLAW - OpenMP (12cores), CLAW - OpenMP (GPU optimized code) (12cores)}

    \end{axis}
  \end{tikzpicture}%
  ~%
  \begin{tikzpicture}%
    \tikzstyle{every node}=[font=\small]
    \begin{axis}[
      title = {B) GPU target vs. parallel x86},
      title style={at={(0.5,-0.15)},anchor=north,yshift=0.5},
      width = 0.45*\textwidth,
      major x tick style = transparent,
      ybar=2*\pgflinewidth,
      bar width=36pt,
      ymajorgrids = true,
      ylabel = {Speedup},
      ytick = {0,1,2,3,4,5,6,7,8,9,10,11,12},
      symbolic x coords={Cray CCE v8.6.2, PGI v17.10},
      xtick = data,
      scaled y ticks = false,
      enlarge x limits=0.25,
      ymin=0,
      legend cell align=left,
      legend style={
        at={(1,1)},
        anchor=north east,
        column sep=1ex
        }
      ]

      \addplot[style={bblack,fill=color2,mark=none}]
               coordinates { (Cray CCE v8.6.2, 1.0) (PGI v17.10, 0.8) };

      \addplot[style={bblack,fill=color3,mark=none}]
               coordinates { (Cray CCE v8.6.2, 11.9) (PGI v17.10, 9.6) };

      \addplot[style={bblack,fill=color4,mark=none}]
               coordinates { (Cray CCE v8.6.2, 11.7) (PGI v17.10, 9.7) };

      \legend{CLAW - OpenMP (ref.), CLAW - OpenACC, OpenACC}
    \end{axis}
  \end{tikzpicture}
  \caption[Performance comparison RRTMGP RTE SW solver on GPU]{Performance comparison RRTMGP RTE
  SW solver on GPU - Speedup for CLAW - OpenACC generated version for GPU target and hand-written
  OpenACC version on NVIDIA P100. Domain size (ncol, nlay) = 16384$\times$42 and 14 spectral bands.
  Fastest CLAW - OpenMP results on 12 cores is taken as reference, i.e.
  obtained with Cray CCE v8.6.2}
  \label{fig:perf_sw}
\end{figure}

\begin{itemize}
  \item \textbf{8x} speedup achieved with the \textbf{CLAW CPU/OpenMP} version
        compared to the fastest sequential version. This ratio can be up to
        \textbf{11x} when versions are compared with their respective compiler.
  \item \textbf{12x} speedup is achieved using the \textbf{CLAW GPU/OpenACC}
        version in comparison to the fastest OpenMP from
        Figure \ref{fig:perf_sw}A.
  \item \textbf{85\%} of original code stays unchanged.
  \item The CLAW SCA version is \textbf{Standard Fortran} code.
\end{itemize}

\end{myblock}\vfill

%
% Block 5
%
\begin{myblock}{References}
\footnotesize
\bibliographystyle{abbrv}
\bibliography{./bib}
\end{myblock}\vfill


}\end{minipage}\end{beamercolorbox}
\end{column}
\end{columns}
\end{frame}
\end{document}
